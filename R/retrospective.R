
#' @name retrospective
#' @title Retrospective analysis
#'
#' @description Perform a retrospective analysis, successive removals of most recent years of data to evaluate
#' consistency in model estimates of biomass, recruitment, etc.
#'
#' The `summary` method returns Mohn's rho and the plot method generates a markdown report.
#' @return A `MARSretro` object containing a named lists of arrays generated by the retrospective analysis:
#' - `S_yst` Spawning output array `[y, s, t]` where `t` indexes the retrospective peel
#' - `R_yst` Recruitment array `[y, s, t]`
#' - `F_yst` Apical fishing mortality `[y, s, t]`
#' - `VB_ymft` Vulnerable biomass available to each fishery `[y, m, f, t]`
#' @param MARSassess [MARSassess-class] object
#' @param yret Vector of integers (greater than zero) specifying the years to remove for the retrospective analysis
#' @export
retrospective <- function(MARSassess, yret = 1:5) {

  ret <- lapply(yret, .ret, MARSassess)

  MARSdata <- get_MARSdata(MARSassess)
  ny <- MARSdata@Dmodel@ny
  nm <- MARSdata@Dmodel@nm
  nf <- MARSdata@Dfishery@nf
  ns <- MARSdata@Dmodel@ns

  nret <- length(yret)
  nt <- length(yret) + 1

  F_yst <-
    R_yst <-
    S_yst <- array(NA_real_, c(ny, ns, nt))

  VB_ymft <- array(NA_real_, c(ny, nm, nf, nt))

  for(i in 1:nret) {
    F_yst[1:(ny-yret[i]), , i+1] <- apply(ret[[i]][["F_yas"]], c(1, 3), max)
    R_yst[1:(ny-yret[i]), , i+1] <- ret[[i]][["R_ys"]]
    S_yst[1:(ny-yret[i]), , i+1] <- apply(ret[[i]][["S_yrs"]], c(1, 3), sum)
    VB_ymft[1:(ny-yret[i]), , , i+1] <- apply(ret[[i]][["VB_ymfrs"]], 1:3, sum)
  }
  F_yst[, , 1] <- apply(MARSassess@report[["F_yas"]], c(1, 3), max)
  R_yst[, , 1] <- MARSassess@report[["R_ys"]]
  S_yst[, , 1] <- apply(MARSassess@report[["S_yrs"]], c(1, 3), sum)
  VB_ymft[, , , 1] <- apply(MARSassess@report[["VB_ymfrs"]], 1:3, sum)

  ret_out <- list(S_yst = S_yst, R_yst = R_yst, F_yst = F_yst, VB_ymft = VB_ymft) %>%
    structure(class = "MARSretro")
  attr(ret_out, "Dlabel") <- MARSdata@Dlabel
  return(ret_out)
}


.ret <- function(y, MARSassess) {

  MARSdata <- get_MARSdata(MARSassess)
  getAllS4(MARSdata@Dmodel)
  nf <- MARSdata@Dfishery@nf

  data_new <- MARSdata
  data_new@Dmodel@ny <- nyret <- ny - y

  if (y_phi > nyret) stop("Reduce y_phi")

  data_new@Dfishery@Cobs_ymfr <- MARSdata@Dfishery@Cobs_ymfr[1:nyret, , , , drop = FALSE]
  if (condition == "F") {
    data_new@Dfishery@Csd_ymfr <- MARSdata@Dfishery@Csd_ymfr[1:nyret, , , , drop = FALSE]
    if (any(y_Fmult_f > nyret)) stop("Reduce y_Fmult_f")
  }
  data_new@Dsurvey@Iobs_ymi <- MARSdata@Dsurvey@Iobs_ymi[1:nyret, , , drop = FALSE]
  data_new@Dsurvey@Isd_ymi <- MARSdata@Dsurvey@Isd_ymi[1:nyret, , , drop = FALSE]

  if (length(MARSdata@DCKMR@POP_s)) {
    data_new@DCKMR@POP_s <- lapply(MARSdata@DCKMR@POP_s, function(x) {
      filter(x, .data$y <= .env$nyret, .data$a <= .env$nyret)
    })
  }
  if (length(MARSdata@DCKMR@HSP_s)) {
    data_new@DCKMR@HSP_s <- lapply(MARSdata@DCKMR@HSP_s, function(x) {
      filter(x, .data$yi <= .env$nyret, .data$yj <= .env$nyret)
    })
  }

  parameters <- MARSassess@obj$env$parList()
  map <- MARSdata@Misc$map
  random <- MARSdata@Misc$random

  parameters[["log_rdev_ys"]] <- parameters[["log_rdev_ys"]][1:nyret, , drop = FALSE]
  if (!is.null(map[["log_rdev_ys"]])) {
    map[["log_rdev_ys"]] <- local({
      m <- matrix(map[["log_rdev_ys"]], ny, ns)
      factor(m[1:nyret, ])
    })
  }
  parameters[["mov_g_ymars"]] <- parameters[["mov_g_ymars"]][1:nyret, , , , , drop = FALSE]
  if (!is.null(map[["mov_g_ymars"]])) {
    map[["mov_g_ymars"]] <- local({
      m <- array(map[["mov_g_ymars"]], c(ny, nm, na, nr, ns))
      factor(m[1:nyret, , , , ])
    })
  }
  parameters[["mov_v_ymas"]] <- parameters[["mov_v_ymas"]][1:nyret, , , , drop = FALSE]
  if (!is.null(map[["mov_v_ymas"]])) {
    map[["mov_v_ymas"]] <- local({
      m <- array(map[["mov_v_ymas"]], c(ny, nm, na, ns))
      factor(m[1:nyret, , , ])
    })
  }
  parameters[["log_Fdev_ymfr"]] <- parameters[["log_Fdev_ymfr"]][1:nyret, , , , drop = FALSE]
  if (!is.null(map[["log_Fdev_ymfr"]])) {
    map[["log_Fdev_ymfr"]] <- local({
      m <- array(map[["log_Fdev_ymfr"]], c(ny, nm, nf, nr))
      factor(m[1:nyret, , , ])
    })
  }

  fit <- fit_MARS(data_new, parameters, map, random, do_sd = FALSE, silent = TRUE)
  return(fit@report)
}

#' @rdname retrospective
#' @param x,object Output of `retrospective` function
#' @param var Character to indicate the metric, the item in the `MARSretro` list to be plotted. See details below.
#' @param s Integer for the stock index to plot
#' @param f Integer for the fleet index to plot
#' @param ... Not used
#' @importFrom gplots rich.colors
#' @importFrom graphics legend
#' @returns
#' `plot.MARSretro` returns individual figures using base graphics.
#' @export
plot.MARSretro <- function(x, var = c("S_yst", "R_yst", "F_yst", "VB_ymft"), s = 1, f = 1, ...) {
  var <- match.arg(var)
  Dlabel <- attr(x, "Dlabel")
  year <- Dlabel@year
  nm <- max(length(Dlabel@season), 1)

  ylab <- retro_label(var)

  if (grepl("yst", var)) {
    y <- yannual <- x[[var]][, s, ]
    denom <- 1
  } else if (grepl("ymft", var)) {
    yannual <- x[[var]][, , f, ]
    if (length(dim(yannual)) > 2) { # nm = 1
      y <- collapse_yearseason(yannual)
      year <- make_yearseason(year, nm)
      ylab <- paste("Seasonal", tolower(ylab))
    } else {
      y <- yannual
    }
    denom <- nm
  }
  ylim <- c(0, 1.1) * range(y, na.rm = TRUE)

  rcolor <- rich.colors(ncol(y))
  peel <- nrow(y) - apply(y, 2, function(i) sum(!is.na(i)))

  matplot(year, y, xlab = "Year", ylab = ylab, ylim = ylim, lty = 1, typ = "l", col = rcolor, zero_line = TRUE)
  legend("topleft", legend = peel/denom, col = rcolor, lty = 1, bty = "n", title = "Years removed:")

  invisible()
}

#' @rdname retrospective
#' @param by Character indicating whether to calculate to Mohn's rho on stock or fleet-based time series
#' @return
#' `summary.MARSretro` returns a matrix of Mohn's rho.
#' @export
summary.MARSretro <- function(object, by = c("stock", "fleet"), ...) {
  by <- match.arg(by)

  if (by == "stock") {
    ns <- dim(object$S_yst)[2]
    sname <- attr(object, "Dlabel")@stock
    if (length(sname) <= 1) sname <- "rho"

    x <- object[grepl("yst", names(object))]

    rho <- sapply(x, function(i) apply(i, 2, Mohn_rho)) %>%
      t() %>%
      matrix(length(x), ns) %>%
      structure(dimnames = list(sapply(names(x), retro_label), sname))
  } else {
    fname <- attr(object, "Dlabel")@fleet
    if (length(fname) <= 1) fname <- "rho"

    x <- object[grepl("ymft", names(object))]
    ny <- dim(x[[1]])[1]
    nf <- dim(x[[1]])[3]
    nt <- dim(x[[1]])[4]

    # First season
    rho <- sapply(x, function(i) {
      array(i[, 1, , ], c(ny, nf, nt)) %>% apply(2, Mohn_rho)
    }) %>%
      t() %>%
      matrix(length(x), nf) %>%
      structure(dimnames = list(sapply(names(x), retro_label), fname))
  }
  return(rho)
}

Mohn_rho <- function(x) {
  terminal_ind <- apply(x[, -1, drop = FALSE], 2, function(y) sum(!is.na(y)))
  n_peel <- ncol(x) - 1
  rho <- sapply(1:n_peel, function(i) x[terminal_ind[i], i+1])/x[terminal_ind, 1] - 1
  mean(rho)
}


#' @param filename Character string for the name of the markdown and HTML files.
#' @param dir The directory in which the markdown and HTML files will be saved.
#' @param open_file Logical, whether the HTML document is opened after it is rendered.
#' @param render_args List of arguments to pass to [rmarkdown::render()].
#'
#' @return
#' `report.MARSretro` returns a HTML markdown report.
#' @rdname retrospective
#' @importFrom rmarkdown render
#' @importFrom utils browseURL
#' @export
report.MARSretro <- function(object, filename = "retro", dir = tempdir(), open_file = TRUE, render_args = list(), ...) {

  sname <- attr(object, "Dlabel")@stock
  fname <- attr(object, "Dlabel")@fleet

  rmd <- system.file("include", "retrospective.Rmd", package = "MARS") %>% readLines()
  rmd_split <- split(rmd, 1:length(rmd))

  fleet_ind <- grep("*ADD FLEET RMD*", rmd)
  stock_ind <- grep("*ADD STOCK RMD*", rmd)
  rmd_split[[fleet_ind]] <- make_rmd_ret_fleet(fname)
  rmd_split[[stock_ind]] <- make_rmd_ret_stock(sname)

  ####### Function arguments for rmarkdown::render
  filename_rmd <- paste0(filename, ".Rmd")

  render_args$input <- file.path(dir, filename_rmd)
  if (is.null(render_args$quiet)) render_args$quiet <- TRUE

  # Generate markdown report
  if (!dir.exists(dir)) {
    message_info("Creating directory: ", dir)
    dir.create(dir)
  }
  write(do.call(c, rmd_split), file = file.path(dir, filename_rmd))

  # Rendering markdown file
  message_info("Rendering markdown file: ", file.path(dir, filename_rmd))
  output_filename <- do.call(rmarkdown::render, render_args)
  message("Rendered file: ", output_filename)

  if (open_file) browseURL(output_filename)
  invisible(output_filename)
}

make_rmd_ret_stock <- function(sname) {
  ns <- max(length(sname), 1)

  rmd <- lapply(1:ns, function(s) {
    header <- if (!length(sname) || length(sname) == 1) NULL else paste("###", sname[s], "\n")
    out <- c("```{r}",
             paste0("plot(object, \"S_yst\", s = ", s, ")"),
             "```\n",
             "```{r}",
             paste0("plot(object, \"R_yst\", s = ", s, ")"),
             "```\n",
             "```{r}",
             paste0("plot(object, \"F_yst\", s = ", s, ")"),
             "```\n")
    c(header, out)
  })
  do.call(c, rmd)
}

make_rmd_ret_fleet <- function(fname) {
  nf <- max(length(fname), 1)

  rmd <- lapply(1:nf, function(f) {
    out <- c("```{r}",
             paste0("plot(object, \"VB_ymft\", f = ", f, ")"),
             "```\n")
  })
  do.call(c, rmd)
}

retro_label <- function(var) {
  switch(
    var,
    "F_yst" = "Fishing mortality",
    "R_yst" = "Recruitment",
    "S_yst" = "Spawning output",
    "VB_ymft" = "Vulnerable biomass"
  )
}

